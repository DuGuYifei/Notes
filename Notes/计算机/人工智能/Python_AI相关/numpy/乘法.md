# 乘法

## 广播规则

1. 对齐数组的形状：
   1. 通过在形状较小的数组前面补 1，使得两个数组的维度数相同。
2. 从最后一个维度开始比较：
   1. **如果两个维度的大小相同，或者其中一个维度的大小为 1，则这两个维度是兼容的。**
   2. 如果在任何一个维度上不兼容（既不相等也不为 1），则引发 ValueError。
3. 扩展维度为 1 的数组：
   1. 在计算时，沿着维度为 1 的方向扩展数组，使其匹配另一个数组的大小。

## 案例1

```python
import numpy as np

a = np.array([[1, 2, 3], [4, 5, 6]])  # 形状 (2, 3)
b = np.array([1, 2, 3])  # 形状 (3,)

print(a * b)
```

```python
[[ 1  4  9]
 [ 4 10 18]]
```

原理：
1. `b` 的形状是 `(3,)`，`a` 的形状是 `(2, 3)`，`b` 的形状在左边补 1，变成 `(1, 3)`，然后两个形状从右向左比较，如果维度相同或者其中一个维度是 1，那么这个维度就是广播维度。
2. 比较每个维度：
   1. 第一维度：2 和 1 是兼容的（因为其中一个为 1）
   2. 第二维度：3 和 3 是相同的
3. 利用复制的方式，将 `b` 扩展成 `(2, 3)`，然后再相乘。

## 案例2

```python
a = np.array([1, 2, 3])  # 形状 (3,)
b = np.array([[1], [2], [3]])  # 形状 (3, 1)

print(a * b)
```

```python
[[1 2 3]
 [2 4 6]
 [3 6 9]]
```

原理：
1. `a` 的形状是 `(3,)`，`b` 的形状是 `(3, 1)`，`a` 的形状在左边补 1，变成 `(1, 3)`
2. 比较每个维度：
   1. 第一维度：1 和 3 是兼容的（因为其中一个为 1）
   2. 第二维度：3 和 1 是兼容的（因为其中一个为 1）
3. 扩展 `a` 和 `b`，使得两者的形状相同为 `(3, 3)`，然后再相乘。

```
a -> [[1, 2, 3],
      [1, 2, 3],
      [1, 2, 3]]

b -> [[1, 1, 1],
      [2, 2, 2],
      [3, 3, 3]]
```

## 案例3 - 不兼容

```python
a = np.array([1, 2, 3])  # 形状 (3,)
b = np.array([[1, 2], [3, 4]])  # 形状 (2, 2)

try:
    c = a * b
except ValueError as e:
    print(e)  # 输出: operands could not be broadcast together with shapes (3,) (2,2)
```