# KCP

KCP 是一个运行在 UDP 上的高性能、可靠传输协议。目标是**降低延迟的同时保证数据可靠性**，常用于游戏、直播、穿墙传输等场景。

---

## 🚀 1. 重传机制（Reliable Transmission）

### 📌 原理：选择性重传（Selective Repeat ARQ）

- 每个数据包有唯一的 **序列号（sn）**
- 接收端收到后会发送 **ACK 确认**
- 发送端记录哪些包已发送但未确认
- **超时未确认的包会被重发**

### ✅ 优化点

- **快速重传**：重复收到 3 次 ACK，立即重传目标包（无需等超时）
- **ACK 聚合**：多个 ACK 可打包成一个包发送，节省流量

---

## 📦 2. 顺序恢复（Order Restoration）

### 📌 原理：接收缓冲区 + 有序交付

- 接收端保存乱序包，等待缺失部分补齐
- 所有数据按序排列后，再交付给上层逻辑
- 类似于拼图机制，确保数据完整有序

---

## ⚖️ 3. 流量控制（Flow Control）

### 📌 原理：滑动窗口机制

- 接收端每次反馈剩余窗口大小（rmt_wnd）
- 发送端根据窗口大小决定是否继续发包
- 防止接收端处理不过来导致丢包或内存暴涨

---

## 🌐 4. 拥塞控制（Congestion Control）

### 📌 类 TCP Reno 拥塞控制（可选）

- 使用 **拥塞窗口（cwnd）** 控制发送速率
- 包丢失时：减少 `cwnd`
- 正常通信时：逐步增加 `cwnd`
- 防止因发送过快导致网络拥堵

> 🎮 注：游戏中经常 **关闭拥塞控制**，以追求更低延迟和更稳定体验

---

## 🔧 KCP 特点总结

| 特性           | 是否支持 | 说明                           |
|----------------|-----------|--------------------------------|
| 基于 UDP       | ✅        | 可运行在任何 UDP 网络之上       |
| 重传机制       | ✅        | 选择重传 + 快速重传             |
| 顺序恢复       | ✅        | 缓冲乱序包，拼齐后交付           |
| 流量控制       | ✅        | 滑动窗口，防止接收端超载         |
| 拥塞控制       | ✅（可关闭）| 类 TCP 控制拥塞，游戏中可关闭   |
| 面向消息传输   | ✅        | 每个包为独立消息，无粘包分包问题 |

---

## 🔗 推荐资源

- GitHub 项目：https://github.com/skywind3000/kcp
- 协议文档：https://github.com/skywind3000/kcp/blob/master/README.zh.md
- 实现语言：C/C++、Go、Rust、Python 等均有移植版本

---

## 🧠 Tips

- KCP 不是“万能神器”，适用于**低延迟场景**，不适合大文件传输。
- 对比 TCP，KCP 的优点在于 **更强的控制权和自定义空间**。

