# 并查集


![](2022-08-01-01-29-27.png)

这种并查集结构，不用只找每个数字的质数因子，它可以只要所有因子，然后层层被parent递进


[LeetCode_952.按公因数计算最大组件大小.cpp](../../LeetCode/952.按公因数计算最大组件大小.cpp)
```cpp
class UnionFind{
private:
    vector<int> parent; // 存放每个数字的parent（parent就是因子），长度不是原数字的长度，而是原数组最大值的长度
    vector<int> rank;   // 存放每个父亲节点的儿子数量，按儿子数量合并，存入多的（其实可以不要，直接每次让y存入x就行了,y是原数字，x是因子）, 但是速度会下降，因为根据经常连接的点可以找出谁更常用，会加速新数字找parent

public:
    UnionFind(int n)
    {
        parent = vector<int> (n);   
        rank = vector<int>(n);
        
        // 先将每个数的parent初始化为自己
        for(int i = 0; i < n; i++)
        {
            parent[i] = i;
        }
    }

    // 因为这是个链型结构，不是每个parent作为父节点就连上所有子节点的
    // 比如24父亲可能会是8，8的父亲是4，4的父亲如果就是4，那就停下，否则继续往前，最后应该会停在一个质数上
    int find(int x)
    {
        if(parent[x] != x)
        {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void uni(int x, int y)
    {
        int rootx = find(x);
        int rooty = find(y);

        //下面其实可以不用，直接parent[rooty] = parent[rootx]就行了，y是origin，x是parent才行
        //但是速度会下降，因为根据经常连接的点可以找出谁更常用，会加速新数字找parent
        if(rootx != rooty)
        {
            if(rank[rootx] > rank[rooty])
                parent[rooty] = rootx;
            else if (rank[rootx] < rank[rooty])
                parent[rootx] = rooty;
            else
            {
                parent[rooty] = rootx;
                rank[rootx]++;
            }
        }
    }
};

```