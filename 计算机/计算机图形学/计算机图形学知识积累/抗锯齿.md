# 抗锯齿

## 注意点
AA (Anti-Aliasing) 涉及到采样， [12Sampling.md](../TUM实时计算机图形/12Sampling.md) 一文里除了采样，其他的(mipmap等)是为了解决纹理aliasing。

```
屏幕采样（像素内部）
    ├── SSAA
    ├── MSAA

纹理采样（UV→Texel）
    ├── Mipmap
    ├── Anisotropic Filtering

时间采样（跨帧）
    ├── TAA

后处理
    ├── FXAA
```

# 0. 统一模型：一个像素到底在算什么？

把一个像素想成一个“小格子区域”。真实世界里，这个格子里可能同时覆盖了：

* 一部分三角形（物体）
* 一部分背景

理想情况下，这个像素应该显示：

> 物体覆盖比例 × 物体颜色 + 背景覆盖比例 × 背景颜色

也就是“面积平均”。

但 GPU 不能真的算连续面积平均，于是用 **采样点** 来近似。

采样点越多，越接近真实平均。

---

# 1. 无抗锯齿（1x Sampling，默认）

**做法：**只看像素中心点。

* 中心点在三角形内 → 整个像素用物体颜色
* 不在 → 整个像素用背景

**结果：**边缘会跳格子（台阶），出现锯齿。

你可以把它理解成“投票只有 1 票”。

---

# 2. SSAA（Super Sampling Anti-Aliasing）

**核心：**在每个像素里放更多采样点，并且每个采样点都完整算一次颜色。

例如 4x SSAA：

* 一个像素有 4 个采样点
* 每个采样点都运行一次片段着色（算光照/纹理）
* 最后把 4 个颜色平均，作为这个像素颜色

**效果：**最好
**代价：**最贵（因为“颜色计算次数”也乘上去了）

✅ 解决：几何锯齿、纹理锯齿、着色闪烁（几乎都能缓解）
❌ 代价：性能/显存成本非常大

一句话记忆：**“多点采样 + 每点都算颜色”**

---

# 3. MSAA（Multi-Sample Anti-Aliasing）

你可以把 MSAA 理解成“更聪明的省钱版 SSAA”。

**核心：**同样在像素里放多个采样点，但只在“需要时”多采样，并且**颜色只算一次**。

它分两件事：

### 3.1 覆盖测试（Coverage）

* 对一个像素的多个采样点判断：哪些点被三角形覆盖
* 得到一个“覆盖比例”（例如 4 个点里 2 个在内 → 50%）

### 3.2 颜色计算（Shading）

* 颜色通常只算一次（按中心或某个代表点）
* 最后用覆盖比例去混合背景与物体颜色

**效果：**对边缘（几何边界）很有效
**代价：**比 SSAA 便宜很多

✅ 主要解决：**几何边缘锯齿**
❌ 解决不了：**纹理细节造成的闪烁**（因为纹理颜色本身没被多采样）

一句话记忆：**“多点判断覆盖，但颜色不多算”**

---

# 4. FXAA（Fast Approximate AA）

这类方法完全不改变光栅化采样，它是：

> 图像渲染完以后，在屏幕后处理阶段做“边缘检测 + 模糊平滑”。

**做法：**

* 找到看起来像边缘的像素（亮度变化剧烈）
* 对边缘做滤波/模糊，让台阶变平滑

✅ 优点：很快，通用
❌ 缺点：会模糊细节，边缘“糊”

一句话记忆：**“先渲染完，再用滤镜糊边”**

---

# 5. TAA（Temporal AA，时间抗锯齿）

核心思想：

> 同一个像素在不同帧会看到略微不同的采样位置，把多帧累积当成更多采样。

常见做法是：

* 每帧让采样位置轻微抖动（jitter）
* 把当前帧与历史帧融合（平均/滤波）

✅ 优点：效果好、成本相对低
❌ 缺点：可能拖影/鬼影（运动时历史信息不准）

一句话记忆：**“用时间换采样数”**

---

# 6. 你现在需要掌握的对比（最关键）

把所有方法统一到两个问题上：

1. **采样点数量增加在哪里？**
2. **颜色计算次数是否增加？**

| 方法   | 采样点变多  | 颜色计算变多  | 主要解决     |
| ---- | ------ | ------- | -------- |
| 无AA  | 否      | 否       | 无        |
| SSAA | 是（像素内） | 是（每点算）  | 几何+纹理+着色 |
| MSAA | 是（覆盖）  | 否（通常一次） | 几何边缘     |
| FXAA | 不改变采样  | 不改变     | 视觉边缘（模糊） |
| TAA  | 是（跨帧）  | 不直接增加   | 综合（可能拖影） |

---