# multiset

## 介绍
* 底层:红黑树
* 有序
* 不去重
* multiset的查找的时间复杂度是`Olog2N`
* multiset的底层存储的是`<value, value>`的键值对

## erase
会删除所有比较函数相同的元素

### c.erase(elem)

删除与elem相等的所有元素，返回被移除的元素个数。

### c.erase(pos)

移除迭代器pos所指位置元素，无返回值。

### c.erase(beg,end)

移除区间[beg,end)所有元素，无返回值。


---

## 什么时候用 `multiset`？
你会使用 `multiset`，当你**需要按顺序存储重复元素**，并希望：

1. **自动排序**（比如按升序维护元素）；
2. **允许重复值**；
3. **频繁进行插入、删除、查找最小/最大元素**。

### 使用场景示例：

- 维护一个有序窗口中的元素，用于滑动窗口问题（比如中位数）；
- 频繁插入和删除数值，还需要快速知道当前的最小值或最大值；
- 实现某些算法时需要**可重复的排序集合**（例如：有权图中的路径权重集合）。

---

## 为什么使用 `unordered_map`？

- **快速操作**：插入、删除、查找平均为 O(1) 时间复杂度；
- **不需要排序时，比 multiset 更快**；
- **节省空间**：相比 multiset 保存多个副本，map 只存 key 和 count；
- **适合做频率统计或模拟 multiset 行为**。

---

## 为什么叫 `set`？明明允许重复？
这是个语言历史问题。

- `multiset` 名字来源于数学中“多重集”的概念；
- 它扩展了 `set` 的语义 —— 虽然普通集合不允许重复，但 `multiset` 允许；
- 名字中带 `set` 是因为它保留了集合的一些基本特性（如包含关系、并交差等运算）。

---

## 会更快吗？对比总结：

| 数据结构        | 是否有序 | 是否允许重复 | 插入/删除/查找复杂度 | 优势                               |
|-----------------|-----------|----------------|-----------------------|------------------------------------|
| `set`           | 有序      | 否             | O(log n)              | 元素唯一、自动排序                |
| `multiset`      | 有序      | 是             | O(log n)              | 自动排序 + 支持重复元素           |
| `unordered_set` | 无序      | 否             | 平均 O(1)             | 更快的操作速度                    |
| `unordered_map` | 无序      | 记录频次       | 平均 O(1)             | 模拟 multiset，适合频率统计       |

如果你：
- 需要**排序**：用 `multiset`
- 只关心频率、不要顺序：用 `unordered_map`
- 追求速度、值唯一：用 `unordered_set`

---
